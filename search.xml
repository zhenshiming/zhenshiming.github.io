<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F07%2F07%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1hexo new "My New Post" More info: Writing Run server1hexo server More info: Server Generate static files1hexo generate More info: Generating Deploy to remote sites1hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[Notes for MySQL]]></title>
    <url>%2F2018%2F06%2F18%2FNotes-for-MySQL%2F</url>
    <content type="text"><![CDATA[这是我Java培训时MySQL部分的笔记，只是按时间顺序简单的罗列了一下，没有做特别的整理，只是想在这里记录一下。一方面是为了分享，另一方面是为了自己方便查阅。 数据库（DataBase）概念根据数据结构，对数据进行管理、访问、存储的仓库。 设计数据库的步骤 数据结构的设计（ER图） 逻辑结构设计（关系型数据库MySQL、网状、层次、NoSQL） 也就是选择哪种数据库管理系统（软件） 物理结构设计（字段信息……） 数据库的结构数据库系统（DataBaseSystem）包括数据库（DataBase）、数据库管理系统（DataBaseManageSystem–DBMS） 结构DataBase -&gt; DBMS -&gt; 数据库应用软件（SQLYog） 关系型数据库：根据关系模型搭建的数据库。关系模型：二维数据表模型、和数据之间的关系。 基本语法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899-- 创建数据库CREATE DATABASE test1013;-- 删除数据库DROP DATABASE test1013;-- 查看创建的数据库SHOW DATABASES;-- 使用数据库USE test1013;-- 创建表-- 字符型 varcharCREATE TABLE lianyiqun( lianName VARCHAR(20), color VARCHAR(10), oldPrice DECIMAL(10,2), currentPrice DECIMAL(10,2), amount INT)-- 删除表DROP TABLE lianyiqun;-- 增删改查-- 增加数据INSERT INTO lianyiqun (lianName, color)VALUES ("碎花连衣裙","红色");INSERT INTO lianyiqunVALUES("蕾丝连衣裙","黑色",199.99,99.99,50);-- 一条语句添加多条记录INSERT INTO lianyiqun VALUES("蕾丝连衣裙1","黑色1",119.99,91.99,51),("蕾丝连衣裙2","黑色2",119.99,91.99,51),("蕾丝连衣裙3","黑色3",119.99,91.99,51),("蕾丝连衣裙4","黑色4",119.99,91.99,51);-- 查询SELECT lianName AS "商品名称", color AS "颜色"FROM lianyiqun;-- 查询记录的条数SELECT COUNT(1) FROM lianyiqun;-- * 通配符 表示所有数据SELECT * FROM lianyiqun;-- 查询指定的数据SELECT lianName, color, oldPrice, currentPrice, amountFROM lianyiqun WHERE currentPrice != 99;-- &gt;, &lt;, !=, &lt;&gt;-- OR ANDSELECT lianName, color, oldPrice FROM lianyiqunWHERE color="黑色1" AND color="黑色2";-- 查询区间范围的数据SELECT * FROM lianyiqunWHERE currentPrice BETWEEN 91 AND 99;SELECT * FROM lianyiqun;-- 删除一行DELETE FROM lianyiqun WHERE amount=50;-- 删除全部DELETE FROM lianyiqun;-- 删除多行DELETE FROM lianyiqunWHERE color="黑色1" OR color="黑色2";-- 修改-- 修改多行UPDATE lianyiqun SET lianName="迷彩服";-- 修改一行UPDATE lianyiqun SET lianName="黑色迷彩服" WHERE color="黑色3";-- 复制记录到另一张表(若表不存在则报错)INSERT INTO micaifu SELECT * FROM lianyiqun;CREATE TABLE micaifu( lianName VARCHAR(20), color VARCHAR(10), oldPrice DECIMAL(10,2), currentPrice DECIMAL(10,2), amount INT)SELECT * FROM micaifu;-- 目标表不存在时，创建并复制原始表的所有数据CREATE TABLE micaifu2 AS SELECT * FROM micaifu; SQL(Structured Query Language) 结构化查询语言 jQuery 数据完整性 查询速度 四个约束 三大范式 索引(index) 好处：提升数据库的读写速度坏处：增大了表的物理空间目录拼音聚集索引（聚簇索引）：索引限制物理存储的位置；一张表最多只有一个聚集索引非聚集索引（非聚簇）：物理存储位置与逻辑顺序没有必然相关性。 三大范式（Normal Form） 保障数据完整性，减少数据冗余，提升表数据的读写速度 1NF 列不可再分（列的原子性）。 2NF 主键能唯一标识当前记录，所有的非主键列和主键唯一相关。 3NF 主键能唯一标识当前记录，并且消除传递依赖。 根据已有的 DBMS 无法创建出不符合 1nf 的表。这句话是错误的，视业务需求而定。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154-- 选择一个数据库USE test1013;-- book(bookId, bookName, bookAuthor, press, bookPrice,-- count, bookInfo)-- DECIMAL(*,2) 相当于 money (SQLServer)CREATE TABLE book( bookId INT, bookName VARCHAR(20), bookAuthor VARCHAR(20), press VARCHAR(20), bookPrice DECIMAL(10,2), bookCount INT, bookInfo VARCHAR(200))-- 删除整个表DROP TABLE book;-- 删除表中的记录DELETE FROM book;INSERT INTO book VALUES(1,"MySQL深入浅出","张三","陕西省人民出版社",100.99,100,"测试数据123");SELECT * FROM book;-- 添加索引index -- 非聚集索引CREATE INDEX index_bookId ON book(bookId);-- 删除索引DROP INDEX index_bookId ON book;-- 添加一个聚集索引：设置一个列为主键列就添加了一个聚集索引-- bookId列不能为空，不能重复-- 非空约束（not null）-- 特殊约束（unique）-- 建表的时候添加约束CREATE TABLE book( bookId INT NOT NULL, bookName VARCHAR(20), bookAuthor VARCHAR(20), press VARCHAR(20), bookPrice DECIMAL(10,2), bookCount INT, bookInfo VARCHAR(200))-- 查看表结构DESC book;-- 删除非空约束-- 修改列列名、属性ALTER TABLE book CHANGE bookId bookId INT;-- 修改表的列名和数据类型（bookName为原名，bookTopic为修改后的名称）ALTER TABLE book CHANGE bookName bookTopic VARCHAR(20);-- 在已有的表中添加非空约束ALTER TABLE book CHANGE bookId bookId INT NOT NULL;-- 特殊性（唯一性）约束-- constraintALTER TABLE book ADD CONSTRAINT uq UNIQUE(bookId);INSERT INTO book (bookid,bookTopic, bookAuthor, press,bookPrice,bookCount, bookInfo)VALUES(2,"MySQL深入浅出","张三","陕西省人民出版社",100.99,100,"测试数据123");SELECT * FROM book;-- default 默认值CREATE TABLE book1( bookId INT NOT NULL, bookName VARCHAR(20) NOT NULL, press VARCHAR(20) DEFAULT "陕西人民出版社")INSERT INTO book1(bookId,bookName, press)VALUES(2,"哈哈哈哈","山西省人民出版社");SELECT * FROM book1;DROP TABLE book1;-- 添加一个主键-- 建表时添加CREATE TABLE book1( bookId INT PRIMARY KEY, bookName VARCHAR(20))DESC book1;INSERT INTO book1 VALUES(1,"MySQL深入浅出");-- 在已有的表中添加一个主键ALTER TABLE book1 ADD CONSTRAINT pk_bid PRIMARY KEY (bookId);-- 删除一个主键ALTER TABLE book1 DROP PRIMARY KEY;-- 外键-- 修改book表DESC book;SELECT * FROM book;-- 在book表中添加一列【出版社地址】ALTER TABLE book ADD COLUMN pressAddr VARCHAR(30);-- 删除一列ALTER TABLE book DROP COLUMN pressAddr;-- 在book表中添加一列【地址】到press列之后ALTER TABLE book ADD COLUMN pressAddr VARCHAR(30) AFTER press;-- 在book表中添加一列到第一列的位置ALTER TABLE book ADD COLUMN bookNumber INT FIRST;-- 写一个press表，并设置pressId为主键CREATE TABLE press( pressId INT PRIMARY KEY, pressName VARCHAR(20), pressAddr VARCHAR(20))DESC book;SELECT * FROM book;ALTER TABLE book DROP COLUMN pressAddr;ALTER TABLE book DROP COLUMN press;ALTER TABLE book ADD COLUMN pressId INT;-- 在book表中添加pressId列为链接到press表中的pressId列的外键约束-- 外键对应的外键表的列是外键表的主键列-- 外键所在的列是主表的外键列ALTER TABLE book ADD CONSTRAINT fk_pidFOREIGN KEY (pressId) REFERENCES press(pressId);-- 查看创建表格的语句SHOW CREATE TABLE book;SELECT * FROM book;UPDATE book SET bookPrice=10,bookTopic="MySQL性能调优" WHERE bookId=2;-- 根据价格排序(默认升序)(升序：ASC；降序DESC)SELECT * FROM book ORDER BY bookPrice DESC; 数据类型数字型 类型 大小 与 java 对比 TINYINT 1字节 byte SMALLINT 2字节 short MEDIUMINT 3字节 INT 4字节 integer BIGINT 8字节 long 浮点型 FLOAT 4字节 DOUBLE 8字节 DECIMAL 字段添加的小数超出范围，会报警告（字符截取 Truncate ）四舍五入 浮点型和 DECIMAL 的区别 警报 精度。浮点型（二进制）丢失精确度， DECIMAL （十进制）没有误差。 字符型(括号中的数字表示值的长度) char(M) 大小是长度M 字节/符，UTF-8 汉字(M*3)字节 varchar(M) 大小是长度M +1 字节，汉字（） char 定长， varchar 变长 “哈 “ char text（ TINYTEXT 255（$2^8-1$）字节85个UTF-8汉字， TEXT 65535（$2^{16}-1$）2W汉字， LONGTEXT 10亿汉字） NCHAR、NVARCHAR、NTEXT 用来处理 Unicode 码 日期时间类型 时间类型 格式 大小 year 年 1字节 $2^8$ (-128~127) (1901-2155) time 时间 HH:MM:SS 3字节 date 日期 yyyy-mm-dd 3字节 datetime 时间日期 8字节 timestamp 时间戳 4字节 视图和表的异同 数据的二维结构 数据表的数据是真实存在磁盘中的物理表，视图是 DBMS 临时生成的数据(虚表) 视图可以限制用户的访问，对关键字段进行保护 方便对于复杂的 SQL 进行反复调用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177-- 权限管理-- 视图-- 基本函数CREATE TABLE numbertest( mytinyint TINYINT, mysmallint SMALLINT, mymediumint MEDIUMINT, myint INT, mybigint BIGINT)CREATE TABLE floattest( myfloat FLOAT(5,2), mydouble DOUBLE(5,2), mydecimal DECIMAL(5,2))SELECT * FROM floattest;INSERT INTO floattest VALUES(4.567,4.567,4.567);CREATE TABLE chartest( mychar CHAR(20), myvarchar VARCHAR(20), mytinytext TINYTEXT, mytext TEXT, mylongtext LONGTEXT)INSERT INTO chartest (mychar) VALUES('哈哈');SELECT * FROM chartest;CREATE TABLE mytimetest( myyear YEAR, mytime TIME, mydate DATE, mydatetime DATETIME, mytimestamp TIMESTAMP)INSERT INTO mytimetest (myyear) VALUES(2155);SELECT * FROM mytimetest;-- 权限管理-- 创建一个用户(用户名jerry,密码1234)CREATE USER 'jerry'@'localhost' IDENTIFIED BY '1234';-- 权限的授予-- 授予查询表的权限GRANT SELECT ON test1013.bookTO 'jerry'@'localhost' IDENTIFIED BY '1234';-- 授予插入、修改、删除表的权限GRANT INSERT ON test1013.bookTO 'jerry'@'localhost' IDENTIFIED BY '1234';-- 刷新权限FLUSH PRIVILEGES;-- 授予全部权限GRANT ALL PRIVILEGES ON *.*TO 'jerry'@'localhost' IDENTIFIED BY '1234'WITH GRANT OPTION;-- 所有权限的回收REVOKE ALL ON *.* FROM 'jerry'@'localhost';-- 查看用户表USE mysql;SELECT * FROM mysql.user;-- 删除用户表的记录DELETE FROM mysql.user WHERE user.user = 'jerry';-- 删除用户的全部信息DROP USER 'jerry'@'localhost';DESC mysql.user;-- 联合主键(不推荐使用)CREATE TABLE mysqltest( myid INT, mynumber INT, CONSTRAINT pk_id PRIMARY KEY(myid, mynumber))DROP TABLE mysqltest;-- 视图-- 视图的创建CREATE VIEW book_view AS SELECT * FROM book;-- 修改视图ALTER VIEW book_view AS SELECT bookId, bookTopic, pressId FROM book;-- 查看一个视图(使用方法和表一样)SELECT * FROM book_view;--SELECT * FROM book;SELECT * FROM press;-- 创建或修改CREATE OR REPLACE VIEW book_viewAS SELECT b.bookId, b.bookTopic, b.bookAuthor,p.pressId,p.pressName FROM book AS b,press AS p WHERE b.pressId=p.pressId;SELECT * FROM book_view;-- 修改视图中记录的内容UPDATE book_view SET bookAuthor="李四" WHERE bookId=2;-- 基本函数-- DUAL（伪表），方便程序员select from表没有对象的时候使用SELECT 1 FROM DUAL;-- 数学函数-- 求绝对值SELECT ABS(-8989) FROM DUAL;-- 求平方根SELECT SQRT(9) FROM DUAL;-- PISELECT PI() FROM DUAL;-- round(保留几位小数，并四舍五入)SELECT ROUND(1.234567,3) FROM DUAL;-- ceil ceiling 向上取整SELECT CEIL(1.111) FROM DUAL;SELECT CEILING(1.22) FROM DUAL;-- floor 向下取整SELECT FLOOR(-1.999) FROM DUAL;-- 对数函数SELECT LOG(10,10) FROM DUAL;-- lnSELECT LN(2.71828) FROM DUAL;-- 字符型函数-- 得到一个字符的长度SELECT LENGTH('哈哈1') FROM DUAL;-- 反转一个字符SELECT REVERSE('上海自来水') FROM DUAL;-- 字符拼接SELECT CONCAT('a','b','c') FROM DUAL;-- 去空格charSELECT RTRIM('abc ') FROM DUAL;SELECT LTRIM(' abc') FROM DUAL;SELECT TRIM(' abc ') FROM DUAL;-- 使用分割符拼接-- 1234-- 1,2,3,4SELECT CONCAT_WS(',','1','2','3','4') FROM DUAL;-- abc,abc, abc = abc,abc,abcSELECT CONCAT_WS(',','abc','abc',TRIM(' abc')) FROM DUAL;-- 日期时间函数-- 得到当前的日期和时间SELECT NOW() FROM DUAL;-- 得到当前的日期SELECT CURRENT_DATE() FROM DUAL;-- 得到当前时间SELECT CURRENT_TIME() FROM DUAL; 截断表和 delete 语句的区别 截断表重置自增长字段的值为 1 截断表效率更高 DELETE 可回滚，截断表不可以 having 和 where 的区别 当没有 group by 语句的时候，都可以进行数据的筛选 group by 后面只能跟 having 不能跟 where，where 是前期汇总（筛选） having 是在结果集产生后进行筛选的，where 是在查询一开始就筛选的 先 where 初步的筛选，然后 group by 分组，最后 having 最后的筛选 聚合函数（统计函数） 根据一组数据（记录）进行计算，得到一个单一的值的函数 count() 除此之外的聚合函数都过滤空值 sum() max() min() avg() count(1) 不会过滤空值,按列检索会过滤空值count(*) 检索全部表count(1) 比 count(*) 快是谬论count(列名) 索引列 主键列 最快count(左边的列) 的速度比 count(右边的列) 快count(小的列) 的速度比 count(大的列) 快 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349-- update delete-- select-- 书籍表SELECT * FROM book;-- drop table book;-- drop table press;-- AUTO_INCREMENT 自增长，初始为1CREATE TABLE book( bookId INT PRIMARY KEY AUTO_INCREMENT, bookName VARCHAR(10), bookAuthor VARCHAR(20), bookInfo VARCHAR(200), bookPrice DECIMAL(10,2), pressId INT)INSERT INTO book VALUES(DEFAULT,'Mysq','张三丰','',NULL,1);-- 删除表格记录(自增长字段继续增加)DELETE FROM book;-- 截断表TRUNCATE TABLE book;-- 销毁表格DROP TABLE book;-- 范围查询SELECT * FROM book WHERE bookPrice BETWEEN 50 AND 100;SELECT * FROM book WHERE bookprice&gt;=50 AND bookPrice &lt;=100;-- INSELECT * FROM book WHERE bookId IN(1,3,5,7,9);-- 字符串匹配查询-- 查询所有张姓作者的书籍信息-- % 匹配任意多个SELECT * FROM book WHERE bookAuthor LIKE '张%';-- 查询所有张某的书籍信息-- _匹配一个长度SELECT * FROM book WHERE bookAuthor LIKE '张_';-- 空值 "" null-- "".equals();-- String str = null;SELECT * FROM book WHERE bookInfo IS NULL;SELECT * FROM book WHERE bookInfo IS NOT NULL;SELECT * FROM book WHERE bookInfo='';-- order bySELECT * FROM book ORDER BY bookName, bookAuthor;-- limit 开始的行数，取出的行数（左开右闭）SELECT * FROM book;SELECT * FROM book WHERE bookId LIMIT 0,3;SELECT * FROM book WHERE bookId LIMIT 6,9;-- group by-- 分组-- 根据列的值进行数据记录的分组，可根据多个列分组SELECT * FROM book GROUP BY bookName, bookAuthor;SELECT * FROM book GROUP BY bookAuthor;-- having-- have hasNextSELECT * FROM book HAVING bookId&gt;3;SELECT * FROM book WHERE bookId&gt;3;SELECT * FROM book GROUP BY bookName HAVING bookPrice &gt; 100;SELECT *FROM book;CREATE TABLE bookt( bookId INT, bookName VARCHAR(20), bookAuthor VARCHAR(20), bookInfo VARCHAR(200), bookPrice DECIMAL(10,2), pressId INT)INSERT INTO bookt AS SELECT * FROM book;CREATE TABLE booktt AS SELECT * FROM book;DESC booktt;-- 修改booktt表bookId字段的数据类型ALTER TABLE booktt MODIFY bookId INT;INSERT INTO booktt VALUES(NULL,NULL,NULL,NULL,NULL,NULL);SELECT * FROM booktt;SELECT COUNT(bookId) FROM booktt; -- 18SELECT COUNT(1) FROM booktt; -- 33SELECT COUNT(NULL) FROM booktt; -- 0SELECT COUNT(*) FROM booktt;SELECT * FROM book1;SELECT COUNT(bookName) FROM book1;SELECT COUNT(bookId) FROM book1;-- SUMSELECT * FROM book;-- 求book表bookprice字段的值的和SELECT SUM(bookPrice) FROM book;-- Max()SELECT MAX(bookPrice) FROM book;-- MINSELECT MIN(bookPrice) FROM book;-- AVGSELECT AVG(bookPrice) FROM book;-- WHERE GROUP BY 聚合函数 having-- 条件查询SELECT * FROM book;CREATE TABLE press( pressId INT PRIMARY KEY AUTO_INCREMENT, pressName VARCHAR(20), pressAddr VARCHAR(20))ALTER TABLE book ADD CONSTRAINT fk_pid FOREIGN KEY(pressId)REFERENCES press(pressId);SELECT * FROM press;INSERT INTO press VALUES(DEFAULT, '陕西人民出版社','西安');SELECT book.bookId, book.bookName, book.bookAuthor, book.bookPrice, press.pressId, press.pressNameFROM book, pressWHERE book.pressId = press.pressId;-- 别名的条件查询SELECT b.bookId, b.bookName, b.bookAuthor, b.bookPrice, p.pressId, p.pressNameFROM book b, press pWHERE b.pressId=p.pressId;-- 子查询（嵌套查询）CREATE TABLE student( stuId INT PRIMARY KEY AUTO_INCREMENT, stuName VARCHAR(20), stuAge INT, classId INT, CONSTRAINT fk_cid FOREIGN KEY(classId) REFERENCES class(classId))CREATE TABLE class( classId INT PRIMARY KEY AUTO_INCREMENT, className VARCHAR(20))INSERT INTO class VALUES(DEFAULT, NULL);INSERT INTO student VALUES(DEFAULT,'张学友',NULL,NULL);SELECT * FROM student;SELECT * FROM class;-- 查询班级名称为10002的班级都有哪些学生SELECT * FROM student WHERE classId=( SELECT classId FROM class WHERE className='10002');-- 查询10002、10001班的所有学生SELECT * FROM student WHERE classId IN ( SELECT classId FROM class WHERE className IN ('10001','10002'))-- exists-- 返回一个布尔值SELECT * FROM student WHERENOT EXISTS(SELECT classId FROM class WHERE className='10003');-- any-- &gt;= any 只需要大于等于其中的最小值SELECT * FROM student WHERE stuAge &gt; ANY( SELECT stuAge FROM student WHERE classId=1)-- all-- &gt;= all 需要比最大的还要大或者相等SELECT * FROM student WHERE stuAge &gt; ALL( SELECT stuAge FROM student WHERE classId=1)-- 连接查询-- 1、内连接-- 2、外连接(主表和附表，主表的内容会被全部显示)-- 2-1、左外连接-- 2-2、右外连接-- 3、交叉连接SELECT s.stuId, s.stuName, s.stuAge, c.classId, c.classNameFROM student AS s INNER JOIN class AS c ON s.classId = c.classId;-- 左外连接SELECT s.stuId, s.stuName, s.stuAge, c.classId, c.classNameFROM student AS s LEFT JOIN class AS c ON s.classId=c.classId; -- 右外连接SELECT s.stuId, s.stuName, s.stuAge, c.classId, c.classNameFROM student AS s RIGHT JOIN class AS c ON s.classId=c.classId; -- 交叉链接(笛卡尔积)SELECT s.stuId, s.stuName, s.stuAge, c.classId, c.classNameFROM student AS s CROSS JOIN class AS c;SELECT COUNT(1) FROM class;-- union-- 允许将多张查询的结果表联合成为你一个结果表-- 列必须保持一致（数据类型相容）SELECT stuId FROM student WHERE stuAge&gt;18UNION ALLSELECT stuName FROM student WHERE stuName LIKE '张%';-- union / union all-- union all 直接组合查询的结果，速度较快-- union 有去重的功能，性能较低-- 实战USE world;-- 城市表SELECT * FROM city;SELECT * FROM city WHERE countrycode="CHN";-- 查询city表中城市的人口大于任意中国城市人口的城市SELECT * FROM city WHERE population &gt;ANY( SELECT population FROM city WHERE countrycode='CHN');--SELECT * FROM city WHERE population &gt;ALL( SELECT population FROM city WHERE countrycode='CHN');-- 查询那个中国城市的人口最多SELECT MAX(population) FROM city WHERE countrycode='CHN';SELECT * FROM city WHERE population=9696300;SELECT * FROM city WHERE countrycode="CHN" ORDER BY population DESC LIMIT 0,1;DESC city;-- countryDESC country;SELECT * FROM country;SELECT SUM(population) FROM city WHERE countrycode='CHN';-- 查询国家（主要城市）人口超过1亿的所有城市信息SELECT *FROM cityWHERE countrycode IN (SELECT countrycode FROM city GROUP BY countrycode HAVING SUM(population) &gt; 100000000)-- 查询平均寿命最高的国家SELECT CODE,NAME,lifeexpectancy FROM country WHERE lifeexpectancy IS NOT NULL ORDER BY lifeexpectancy;-- 查询亚洲所有国家的详细信息SELECT * FROM country WHERE region LIKE '%ASIA%';SELECT * FROM country WHERE NAME LIKE '%taiwan%';SELECT * FROM country WHERE NAME LIKE 'china';-- 查询整个亚洲的人口总和SELECT SUM(population) FROM country WHERE region LIKE '%ASIA%';-- countrylanguageSELECT * FROM countrylanguage WHERE countrycode='CHN';-- 求西安市讲每种语言的人口数量-- city-- countrylanguageSELECT * FROM city WHERE NAME ='XiÂ´an';SELECT TRUNCATE(c.population * cl.percentage/100,0) AS '人口', cl.language AS '语言', cl.percentage AS '百分比'FROM city AS c INNER JOIN countrylanguage AS clON c.countrycode=cl.countrycode AND c.name='XiÂ´an'; 存储过程 （客户端）编写SQL语句 -&gt; 发送到服务器(DBMS)-&gt; （服务器）编译 -&gt; 执行查询 -&gt; 结果集发送到客户端存储过程：是服务器上的一组具有特定功能的SQL语句集。 减少网络流量 减少代码量 便于反复使用，提升效率，提升安全性 封装。隐藏内部实现的细节，提高代码的复用性。 触发器 是一种特殊的存储过程 表 事件 insert delete update 时间 before after 每一张表只能同时存在一种类型的触发器（最多存在6种）当添加有触发器的表上发生了触发触发器的事件时，触发器的语句就被执行 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310-- 存储过程SELECT bookName FROM book WHERE bookId&gt;5UNIONSELECT bookName FROM book WHERE bookPrice&gt;100;-- 定界符-- delimiter $ &amp;&amp;-- PROCEDURE 过程 程序-- DECLARE 声明-- js var i = 1;-- java int i = 1;-- 定义一个存储过程DELIMITER $CREATE PROCEDURE myproc()BEGIN DECLARE i INT; SET i=101; SELECT i;END;$DELIMITER ;-- 调用CALL myproc();-- 销毁DROP PROCEDURE myproc;-- 有出参的情况DELIMITER &amp;&amp;DROP PROCEDURE IF EXISTS myproc &amp;&amp;CREATE PROCEDURE myproc(IN a INT, IN b INT, OUT result INT)BEGIN DECLARE result INT DEFAULT 0; WHILE a &lt;= b DO SET result = result + a; SET a = a + 1; END WHILE; SELECT result FROM DUAL;END;&amp;&amp;DELIMITER ;CALL myproc(1,100,@result);-- 判断一个数字（输入的数字）的大小DELIMITER &amp;&amp;CREATE PROCEDURE myproc(num INT)BEGIN IF num&gt;100 THEN SELECT '大于100'; ELSEIF num&lt;100 THEN SELECT '小于100'; ELSE SELECT '等于100'; END IF;END;&amp;&amp;DELIMITER ;CALL myproc('1000');-- 类型的隐式转换SELECT * FROM book;-- 联合查询SELECT bookId FROM book WHERE bookId &gt; 1UNIONSELECT bookName FROM book WHERE bookPrice&gt;10;DESC book;-- 输入一个stuId，显示是否成年SELECT * FROM student;UPDATE student SET stuAge=17 WHERE stuId=5;-- ifDELIMITER &amp;&amp;DROP PROCEDURE IF EXISTS myproc &amp;&amp;CREATE PROCEDURE myproc(id INT)BEGIN DECLARE getAge INT; SELECT stuAge INTO getAge FROM student WHERE stuId=id; IF getAge&gt;=18 THEN SELECT '成年'; ELSE SELECT '未成年'; END IF;END;&amp;&amp;DELIMITER ;CALL myproc(1);-- case whenDELIMITER &amp;&amp;DROP PROCEDURE IF EXISTS myproc &amp;&amp;CREATE PROCEDURE myproc(id INT)BEGIN-- declare getAge int default 1; DECLARE getAge INT; DECLARE result VARCHAR(30); SELECT stuAge INTO getAge FROM student WHERE stuId=id; CASE WHEN getAge&lt;18 THEN SET result='未成年'; WHEN getAge&gt;=18 THEN SET result='成年'; WHEN getAge IS NULL THEN SET result='输入有误'; END CASE; SELECT result FROM DUAL;END;&amp;&amp;DELIMITER ;CALL myproc(6);SELECT stuAge FROM student WHERE stuId=10000;-- 姓名：张三-- 地址：null-- 'N/A','未填写'SELECT stuId, stuName, stuAge, classId FROM student WHERE stuId=6;-- 使用case when语句进行空值保护SELECT stuId, stuName, stuAge, CASE WHEN classId IS NULL THEN '未填写' WHEN classId IS NOT NULL THEN classId END AS classIdFROM student WHERE stuId=5;-- 循环-- loop-- repeat-- while-- 循环向一张表中添加n条数据DELIMITER &amp;&amp;DROP PROCEDURE IF EXISTS myproc_insert &amp;&amp;CREATE PROCEDURE myproc_insert(n INT)BEGIN DECLARE i INT DEFAULT 1; insert_loop: LOOP INSERT INTO student VALUES(DEFAULT, CONCAT('张三',i),i,1); SET i = i + 1; IF i &gt; n THEN LEAVE insert_loop; END IF; END LOOP;END;&amp;&amp;DELIMITER ;SELECT * FROM student;CALL myproc(1000);-- repeat-- 求1+。。。。。+nDELIMITER &amp;&amp;DROP PROCEDURE IF EXISTS myproc &amp;&amp;CREATE PROCEDURE myproc(n INT)BEGIN DECLARE i INT DEFAULT 1; DECLARE result INT DEFAULT 0; REPEAT SET result = result + i; SET i = i+1; UNTIL i &gt; n END REPEAT; SELECT result FROM DUAL;END;&amp;&amp;DELIMITER ;CALL myproc(100);-- while-- 循环删除，使得student表的记录的个数维持在n条以内-- 门限 thresholdDELIMITER &amp;&amp;DROP PROCEDURE IF EXISTS myproc_delete &amp;&amp;CREATE PROCEDURE myproc_delete(thd INT)BEGIN DECLARE i INT DEFAULT 0; SELECT COUNT(*) INTO i FROM student; WHILE i &gt; thd DO DELETE FROM student LIMIT 1; SET i = i - 1; END WHILE;END;&amp;&amp;DELIMITER ;CALL myproc(1999);-- 让student表的记录的条数维持在某一个值上DELIMITER &amp;&amp;DROP PROCEDURE IF EXISTS myproc &amp;&amp;CREATE PROCEDURE myproc(thd INT)BEGIN DECLARE num INT DEFAULT 0; SELECT COUNT(*) INTO num FROM student; IF num &gt; thd THEN CALL myproc_delete(thd); ELSEIF num &lt; thd THEN CALL myproc_insert(thd-num); END IF;END;&amp;&amp;DELIMITER ;CALL myproc(1000);-- 截断表（飞快）TRUNCATE TABLE student;SELECT * FROM student;-- 触发器-- create trigger 触发器名称-- 触发器的时间 、 触发的事件 for each row-- 触发器的语句-- 自定义日志表DROP TABLE trigger_log;CREATE TABLE trigger_log( id INT PRIMARY KEY AUTO_INCREMENT, mytime TIME, mylog VARCHAR(30))ALTER TABLE trigger_log MODIFY mylog VARCHAR(200);INSERT INTO trigger_log VALUES(DEFAULT, NOW(),'添加了数据');SELECT * FROM trigger_log;DELIMITER &amp;&amp;DROP TRIGGER IF EXISTS mytrigger &amp;&amp;CREATE TRIGGER mytriggerAFTER INSERT ON student FOR EACH ROWBEGIN INSERT INTO trigger_log VALUES(DEFAULT, NOW(),'添加了数据');END;&amp;&amp;DELIMITER ;DESC student;-- 触发器同步student表中某一个班的人数到class表中的classSum字段SELECT * FROM class;ALTER TABLE class ADD COLUMN classsum INT;INSERT INTO student VALUES(DEFAULT, '李四',22,1),(DEFAULT, '李四2',22,1);-- new old-- insert new-- delete old-- update new oldDELIMITER &amp;&amp;DROP TRIGGER IF EXISTS mytrigger &amp;&amp;CREATE TRIGGER mytriggerAFTER INSERT ON student FOR EACH ROWBEGIN DECLARE i INT DEFAULT 0; SELECT COUNT(*) INTO i FROM student WHERE classId=new.classId; UPDATE class SET classSum=i WHERE classId=new.classId;END;&amp;&amp;DELIMITER ;SELECT * FROM class;SELECT * FROM student;DELETE FROM student WHERE stuId=12;DELIMITER &amp;&amp;DROP TRIGGER IF EXISTS delete_trigger &amp;&amp;CREATE TRIGGER delete_triggerAFTER DELETE ON student FOR EACH ROWBEGIN DECLARE i INT DEFAULT 0; SELECT COUNT(*) INTO i FROM student WHERE classId=old.classId; UPDATE class SET classSum=i WHERE classId=old.classId;END;&amp;&amp;DELIMITER ;-- 修改学生记录的时候，全部写入日志表DELIMITER &amp;&amp;DROP TRIGGER IF EXISTS update_trigger &amp;&amp;CREATE TRIGGER update_triggerAFTER UPDATE ON student FOR EACH ROWBEGIN INSERT INTO trigger_log VALUES( DEFAULT, NOW(), CONCAT_WS(',','原始:',old.stuId,old.stuName,old.stuAge, old.classId,'修改后:',new.stuId,new.stuName,new.stuAge, new.classId) );END;&amp;&amp;DELIMITER ;SELECT * FROM student;-- 修改student表，使触发器生效UPDATE student SET stuName='刘德华', stuAge='50', classId=2 WHERE stuId=11;-- 查看日志表SELECT * FROM trigger_log; SQL SQL （structured query language） 分为 4 种 DML （Data Manipulate Language） 数据操作语言 insert update delete DCL （Data Control Language） 数据控制语言 授权、回收权限 DQL （Data Query Language） 数据查询语言 select DDL （Data Define Language） 数据定义语言 create drop 事务 一组原子性的 SQL 查询。所有的 DML 都会产生事务。 事务的 4 大特性 ACID Atomic 原子性。一个事务必须是一个最小的执行单元。在这个事务的执行过程中，要么全部成功，要么全部失败。不允许部分成功。 Consistency 一致性。在事务开始之前和事务结束之后，系统的数据值必须是一致的。 Isolation 隔离性。事物之间必须隔离。（一个事务结束之前，不允许另一个事务开始） Durability 持久性。事务结束后，对数据库造成的影响必须持久。 隔离级别 4 种 隔离级别越高，安全性（数据正确性）越高，系统的开销更大隔离级别越低，安全性就不能得到保证，但是系统的开销较小 READ-UNCOMMITTED 读未提交（其他事务执行中，未提交的数据可以被其他客户端读取到） READ-COMMITTED 读已提交 REPEATABLE-READ 可重复读（ MySQL 默认） SERIALIZABLE 串行化（vs并行）（所有事务依次执行，当一个事务在执行过程中，其他事务均处于阻塞状态） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186-- 银行转账-- 1、A向B转账1000元RMBCREATE TABLE bank( userId INT PRIMARY KEY AUTO_INCREMENT, userName VARCHAR(30), balance DECIMAL(10,2))INSERT INTO bank VALUES(DEFAULT,'ww',5000);INSERT INTO bank VALUES(DEFAULT,'byl',3000);SELECT * FROM bank;--UPDATE bank SET balance=balance-1000 WHERE userName='byl';UPDATE bank SET balance=balance+1000 WHERE userName='ww';--UPDATE bank SET balance=balance-1000 WHERE userName='ww';UPDATE bank SET balance=balance+1000 WHERE userName='byl';-- 开始事务START TRANSACTION;--UPDATE bank SET balance=balance-1000 WHERE userName='ww';UPDATE bank SET balance=balance+1000 WHERE userName='byl';-- 结束事务-- 回滚ROLLBACK;-- 提交COMMIT;-- 设置事务模式（自动事务/手动事务）SHOW VARIABLES LIKE 'autocommit';-- 修改为手动提交SET autocommit='OFF';SELECT * FROM bank;CREATE TABLE book( bookId INT PRIMARY KEY AUTO_INCREMENT, bookName VARCHAR(30), bookPrice DECIMAL(10,2), bookAuthor VARCHAR(20), bookInfo VARCHAR(200))DELIMITER &amp;&amp;DROP PROCEDURE IF EXISTS myproc &amp;&amp;CREATE PROCEDURE myproc(num INT)BEGIN DECLARE i INT DEFAULT 0; WHILE i &lt; num DO INSERT INTO book VALUES(DEFAULT, CONCAT('西游记',i),99.99+i,'吴承恩','上西天拜佛求经'); SET i = i + 1; END WHILE;END;&amp;&amp;DELIMITER ;CALL myproc(100);SELECT * FROM book;START TRANSACTION;-- 支持回滚，效率较低DELETE FROM book;ROLLBACK;-- 不支持回滚TRUNCATE TABLE book;-- 查看隔离级别SELECT @@tx_isolation;-- READ-UNCOMMITTED 脏读CREATE TABLE duihua( kaima VARCHAR(30))START TRANSACTION;INSERT INTO duihua VALUES('开');UPDATE duihua SET kaima='开玩笑嘛';COMMIT;DELETE FROM duihua;SELECT * FROM duihua;-- READ-COMMITTED 不会有脏读的情况 -- 幻读CALL myproc(100);SELECT * FROM book;START TRANSACTION;UPDATE book SET bookPrice=10;COMMIT;SELECT @@tx_isolation;SET SESSION tx_isolation='read-committed';SELECT * FROM book;-- SERIALIZABLE 串行化 既没有脏读，也没有幻读-- 向book添加书籍DELIMITER &amp;&amp;DROP PROCEDURE IF EXISTS myproc_add &amp;&amp;CREATE PROCEDURE myproc_add(num INT)BEGIN DECLARE i INT DEFAULT 0; START TRANSACTION; WHILE i &lt; num DO INSERT INTO book VALUES(DEFAULT,CONCAT('水浒传',i),1,'施耐庵','测试数据'); SET i = i + 1; END WHILE; COMMIT;END;&amp;&amp;DELIMITER ;CALL myproc_add(50000);SELECT COUNT(*) FROM BOOK;SET SESSION tx_isolation='SERIALIZABLE';-- 锁-- 排它锁 FOR UPDATE-- 共享锁 LOCK IN SHARE MODESTART TRANSACTION;SELECT * FROM book WHERE bookId&lt;100 FOR UPDATE;COMMIT;START TRANSACTION;SELECT * FROM book WHERE bookId&lt;100 LOCK IN SHARE MODE;COMMIT;-- MySQL查询-- 索引：提升查询的速度SELECT COUNT(*) FROM book;EXPLAIN SELECT * FROM book UNION SELECT * FROM book;-- 索引失效-- 全表查询，小表，当大表的查询数据量占30%以上时-- 正常EXPLAIN SELECT bookId, bookName FROM book WHERE bookId &lt; 10;-- 对索引列进行+-*/等运算的时候，索引会失效EXPLAIN SELECT bookId, bookName FROM book WHERE bookId - 1&lt; 9;CREATE INDEX bookName_index ON book(bookName);DESC book;-- 正常EXPLAIN SELECT bookId, bookName FROM book WHERE bookName='111';-- 部分情况下 使用NULL会使索引失效EXPLAIN SELECT bookId, bookName FROM book WHERE bookName IS NOT NULL;-- AND 连接条件的时候，只要有一个索引列，索引就会生效EXPLAIN SELECT bookId, bookName FROM book WHERE bookInfo='1' AND bookPrice=10;-- OR 没有索引列参加时，索引失效EXPLAIN SELECT bookId, bookName FROM book WHERE bookName='1' OR bookPrice=10;-- 部分情况下，查询条件中涉及类型的隐式转换时，索引会失效EXPLAIN SELECT bookId, bookName FROM book WHERE bookName=1;-- 正常EXPLAIN SELECT bookId, bookName FROM book WHERE bookName LIKE '西%';-- 部分情况下，模糊查询中，%在前时，索引失效EXPLAIN SELECT bookId, bookName FROM book WHERE bookName LIKE '%西';-- 部分情况下，HAVING会使索引失效EXPLAIN SELECT bookId, bookName FROM book HAVING bookId&gt;10;]]></content>
      <categories>
        <category>DataBase</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Notes for JavaSE]]></title>
    <url>%2F2018%2F06%2F18%2FNotes-for-JavaSE%2F</url>
    <content type="text"><![CDATA[这是我Java培训时Java基础部分的笔记，只是按时间顺序简单的罗列了一下，没有做特别的整理，只是想在这里记录一下。一方面是为了分享，另一方面是为了自己方便查阅，面试前肯定要看看Java基础。 经济基础决定上层建筑。 没事的时候多看看，没有坏处。只有基础夯实了，才能有更长足的进步。 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class Lesson_02 &#123; public static void main(String[] args) &#123; int a = 100; long b = 100000000000000L; // unlearn // 驼峰命名法 // 帕斯卡命名法 // js: 定义变量用 var 弱引用（js）VS强引用（Java） // js: 定义常量用const；java final final char myFamilyName = '刘'; // 变量提升 // 1、类型兼容（整形之间、浮点型之间） // 2、目标的数据类型必须大于原始数据类型（长度） int int1 = 123; long long2 = 123456778903456l; int int2 = (int)123456778903456l; float f1 = 1.934f; double d1 = f1; double d2 = 1.536253; float f2 = (float)d2; int int3 = (int)f1; System.out.println(int3); // 010 int a1 = 2; // 101 // 1 -- 1 // 10 -- 2 // 100 -- 4 // 1000 -- 8 // 10000 -- 16 // 100000 -- 32 int a2 = 5; int a3 = 33; // 按位与 按位或 按位异或 // 按位与：同真才真，一假则假 // 按位或：同假则假，一真则真 // 按位异或：相异则真，相同则假 a3 = a1 ^ a2; System.out.println(a3); &#125;&#125; 面向对象 OOP (Object Oriented Programming)面向过程 POP (Procedure Oriented Programming) 封装 隐藏代码实现的细节。（保护源代码；让开发可以更加专注于自己的业务需求） 对于全部代码的装配（组装）。 对象 一切皆对象 对象指的是人们进行研究的一切事物。我们能够看得到的、想像得到的，都是对象。 类类是虚拟的，不具体的，是某些具有特定属性（特性、成员变量）和方法（行为、功能）的对象的抽象的结果。 类和对象二者缺一不可。对象是具体化的类。类是抽象化的对象。越往上（抽象），越简单；越往下（具体），越复杂。 方法论 根据业务将需要研究的对象进行抽象，设计类并设计出继承关系 根据每一个class，创建一个对象 冒泡排序(默认是升序)123456789101112131415161718192021222324public class Lesson_05_01 &#123; public static void main(String[] args) &#123; int[] a = &#123; 7, 89, 1992, 63, 75, 8, 8 &#125;; for (int i = 0; i &lt; a.length; i++) &#123; for (int j = 0; j &lt; a.length - 1 - i; j++) &#123; if (a[j] &gt; a[j + 1]) &#123; int temp = a[j + 1]; a[j + 1] = a[j]; a[j] = temp; &#125; &#125; &#125; // 遍历数组 for (int i = 0; i &lt; a.length; i++) &#123; if (i &lt; a.length - 1) &#123; System.out.print(a[i] + ","); &#125; else &#123; System.out.println(a[i]); &#125; &#125; &#125;&#125; 方法的重载 overload在一个类中，具有相同签名(方法名)的方法可以有多个（参数不同） 参数不同： 参数的个数不同； 参数的数据类型不同； 返回值不参与方法的重载 方法的重写 / 覆盖 override 重写指的是在具有继承关系的两个类中，子类和父类具有相同签名（方法名）的方法，会在子类中覆盖父类（方法） 当局部变量和成员变量（变量名相同）共同作用在一个代码块（区域）中的时候，局部变量会把成员变量覆盖，局部变量的优先级大 this 指代的是当前对象，调用的是子类/当前类的 super 调用的是父类的东西 构造器是一种特殊的方法 构造器没有返回值，并且不用void声明的 构造器的签名（方法名）必须和类名保持一致（严格区分大小写） 当用户没有显式地指定构造器的时候，程序会自动添加一个无参的构造器 类本质是数据类型，类的作用是描述对象；有数据类型就有变量，有类就有对象 访问权限子类可以访问父类的公共属性 ,不能访问父类的私有属性 。 修饰符 权限 public private 只有该类可以访问 default 在该类和该包中都可以访问 protected 只有该类和继承该类的子类可以访问，不在同一个包不能访问 static 静态的（变量或者方法）静态修饰的内容会直接加载到内存 不加 static 的属于非静态（），在创建对象的时候加载 方法的 8 种调用规则 同类中静态方法调用静态方法：直接调用（方法名）； 同类中静态方法调用非静态方法：先创建对象，然后使用对象名.方法名的方式调用 同类中非静态方法调用静态方法：直接调用（方法名）； 同类中非静态方法调用非静态方法：直接调用（方法名）； 异类中静态调用静态：直接调用（类名.方法名）； 异类中静态调用非静态方法：先创建对象，然后使用对象名.方法名的方式调用； 异类中非静态调用静态方法：直接调用（类名.方法名）； 异类中非静态调用非静态方法：先创建对象，然后使用对象名.方法名的方式调用。 凡是调用非静态方法，先确认对象是否存在，如果不存在，都要先创建对象凡是调用静态方法，先看是否在同一个类中，如果在，直接调用；如果不在，就使用类名.方法名的方式调用 静态属性静态属性在一个类中只有一份，创建任意多个对象共享这一份变量，这个属性在修改后，其他对象访问到的也会是修改后的值。 加载优先级12345678910111213141516171819202122232425// Father类package com.hellojava.loadpriority;public class Father &#123; // 静态代码块 static &#123; System.out.println("Father类的静态代码块---1加载"); &#125; // 非静态代码块 &#123; System.out.println("Father类的非静态代码块加载"); &#125; // 构造器 public Father() &#123; System.out.println("Father类的无参构造器"); &#125; static &#123; System.out.println("Father类的静态代码块---2加载"); &#125;&#125; 1234567891011121314151617181920212223// Child 类package com.hellojava.loadpriority;public class Child extends Father &#123; static &#123; System.out.println("Child类的静态代码块---1"); &#125; &#123; System.out.println("Child类的非静态代码块"); &#125; public Child() &#123;// super(); System.out.println("Child类的构造器"); &#125; static &#123; System.out.println("Child类的静态代码块---2"); &#125;&#125; 12345678910111213// 测试类Demopackage com.hellojava.loadpriority;public class Demo &#123; public static void main(String[] args) &#123; // 创建一个Father类的对象 // 实例化Father类 // Father f = new Father(); Child c = new Child(); &#125;&#125; 测试结果： Father类的静态代码块---1加载 Father类的静态代码块---2加载 Child类的静态代码块---1 Child类的静态代码块---2 Father类的非静态代码块加载 Father类的无参构造器 Child类的非静态代码块 Child类的构造器 polymorphism 多态一个操作应用于不同对象（事物）的时候，产生不同的效果。 静态性多态 +1234567891011121314public class Test &#123; public static void main(String[] args) &#123; String a = "abc"; String b = "123"; int i = 1; int j = 2; // + 代表字符串的拼接符 String c = a + b; // + 代表加法运算符 int k = i + j; System.out.println(c); System.out.println(k); &#125;&#125; 非静态性多态（运行时多态）父类的对象可以指向子类的空间，可以让这个对象产生子类的行为。 goto(指针保留关键字) 实现多态需要做到： 必须有继承关系 ； 必须实现方法的重写。 父类对象指向子类空间。 访问修饰符 final 当final修饰一个变量/属性时，值不可改变，常量 当final修饰一个类的时候，该类不可以被继承 当final修饰一个方法的时候，该方法不可以被重写 设计模式：单例模式 出于对内存容量、数据安全性的考虑，不能随便无止境地创建对象，类似于计划生育。要设计单例模式，就要从构造器入手通过访问修饰符来控制，以达到只能创建一个实例的目的。 懒汉式12345678910111213141516public class Lanhanshi &#123; private static Lanhanshi instance = null; private Lanhanshi() &#123; &#125; public static Lanhanshi getInstance() &#123; if (instance == null) &#123; instance = new Lanhanshi(); &#125; return instance; &#125;&#125; 饿汉式12345678910111213public class Ehanshi &#123; private static /*final*/ Ehanshi instance = new Ehanshi(); private Ehanshi() &#123; &#125; public static Ehanshi getInstance() &#123; return instance; &#125;&#125; 抽象类抽象类和普通类的区别 抽象类使用 abstract class 修饰，普通类使用 class 修饰 抽象类中可以有抽象方法，普通类中只有普通方法和属性 抽象类不能被实例化，普通类可以 关于继承： 抽象类可以继承抽象类(选择不实现抽象方法)； 抽象类可以继承类； 类不可以继承抽象类（如果类要继承抽象类，必须实现抽象类中的抽象方法） 继承抽象类，需要强制重写（实现）抽象方法；继承类可以重写也可以不重写 抽象方法× 不明确具体的实现细节，不使用 {}× 使用 abstract 修饰× 对于有抽象方法的类，必须声明为 abstract 接口 interface接口是一个纯粹化的抽象类，接口是抽象方法的集合 接口和抽象类的区别 抽象类是 abstract class 修饰， 接口使用 interface。 抽象类有属性和方法，接口里只有抽象方法和静态常量。× 接口中的变量会默认添加 public static final 修饰符变成静态常量；× 接口中的方法会默认添加 public abstract。 抽象类的子类是抽象类，也可以是实现他全部抽象方法的类；接口的子接口是继承关系，类不能继承接口。 抽象类和类只能是单继承，接口可以多重继承。 抽象类可以实现接口，接口不能继承抽象类。 抽象类是对于类别的抽象，接口是对于行为、方式、功能的抽象。 内部类 访问外部类的包括私有在内的属性（访问私有属性：1. 实体类的get/set方法，2. 内部类）。内部类和外部类一样都是独立的类。 × 成员内部类 12345678910111213141516171819202122232425public class Outer &#123; private String memory = "私有属性"; class Inner &#123; public String abc = "inner×abc"; void getMemory() &#123; String abc = "inner-method-ABC"; System.out.println(memory); System.out.println(abc); &#125; &#125; public void get() &#123; Inner i = new Inner(); String abc = "outer-method-abc"; i.getMemory(); System.out.println("outer-get-abc=" + abc); System.out.println("Outer-memory=" + memory); System.out.println("this.memory=" + this.memory); &#125;&#125; × 方法内部类 123456789101112131415161718192021222324252627public class Outer2 &#123; public int x = 1; public void get() &#123; class Inner &#123; int y = 2; public void f1() &#123; int z = 3; System.out.println("" + x + y + z); &#125; &#125; Inner i = new Inner(); i.f1(); &#125; public static void main(String[] args) &#123; Outer2 o = new Outer2(); o.get(); &#125;&#125; × 匿名内部类 在定义之前马上实现抽象方法，在定义完后马上使用 1234567891011121314151617public class Outer3 &#123; public static void main(String[] args) &#123; Outer3 o3 = new Outer3(); Idemo idemo = new Idemo() &#123; public void f1() &#123; System.out.println("Idemo接口的实现方法"); &#125; public void f2() &#123; &#125; &#125;; idemo.f1(); &#125;&#125; × 静态内部类 只能访问外部类中的静态属性静态嵌套类，顶级嵌套类 12345678910111213public class Outer4 &#123; public static int a = 10; public static class Inner4 &#123; public void f1() &#123; System.out.println(a); &#125; &#125;&#125; 容器123456789101112131415161718192021222324252627282930313233343536import java.util.*;public class Demo1 &#123; public static void main(String[] args) &#123; // List // 当前list大小为0 List list = new ArrayList(); list.add(1); list.add(new Integer(10)); list.add("abc"); list.add(0, "haha"); // list.remove(1); if (list.contains(1)) &#123; System.out.println("包含"); &#125; else &#123; System.out.println("不包含"); &#125; System.out.println(list); List list2 = new ArrayList(); list2.add("heihei"); list.addAll(list2); // list.clear(); Object[] objss = list.toArray(); for (Object o : objss) &#123; System.out.println("hahahaha" + o); &#125; StringBuilder str = new StringBuilder("helloworld"); StringBuilder str2 = str.reverse(); System.out.println("反转" + str2); System.out.println("hahahah\t" + ((String) list.get(3)).charAt(0));&#125; ArrayList 和 array 的区别 array 是固定长度的数组， ArrayList 是动态长度（每次增加到当前长度的1.5倍）； 内部元素的种类： array 内部元素可以是基本数据类型和它的包装类，也可以是对象 ArrayList 内部元素只有对象 ArrayList 有更多的方法可供选择 length 用来表示数组的长度属性 length() 用来表示字符串的长度方法 size() 用来表示 List 对象的大小的方法 1234System.out.println(list.size());for (int i = 0; i &lt; list.size(); i++) &#123; System.out.print(list.get(i) + "\t");&#125; foreach 循环1234Object[] objss = list.toArray();for (Object o : objss) &#123; System.out.println("hahahaha" + o);&#125; foreach 循环和其他三种循环的区别 其他三种循环需要定义一个边界； foreach 循环不需要显式地指定边界 foreach 循环需要一次性遍历到头，并且方向是一直向前的 JDK8 新循环 lambda 表达式 12System.out.println("\nlambda表达式\n");list.forEach((aa) *&gt; System.out.print(aa + "\t")); lambda 表达式极简版 12System.out.println("\nlambda表达式极简版\n");list.forEach(System.out::print); AL–ArrayListLL–LinkedList AL LL AL 是基于数组结构，LL 是基于双向链表结构 大数据量时，AL 在添加元素上效率很高，进行列表头部及中间元素删除操作的时候效率很低，进行随机访问的时候效率很高；LL 在添加尾部元素时效率较低，删除头、尾元素时效率很高，删除中间元素时，效率很低 大数据量时，对于频繁增删的情况适用 LL，对于频繁访问的AL合适 V AL 都是基于数组结构 安全性： Vector 是线程安全的（AL、LL都不是） 性能：由于安全性的引入，性能稍弱于 ArrayList HashSet TreeSet HashSet 集合判断两个元素相等不单单是 equals 方法，并且必须 hashCode() 方法返回值也要相等。TreeSet 是排序的。所以它所存储的类需要实现 Comparable 接口。java.lang.Comparable 此接口强行对实现它的每个类的对象进行整体排序。这种排序被称为类的自然排序，类的 compareTo 方法被称为它的自然比较方法。 Set 和 ArrayList Set 支持重复项过滤 ArrayList 支持多个 null， Set 只支持 1 个 null List Set 回顾List 接口的常用实现类：ArrayList LinkedList Vector Set 接口的常用实现类：TreeSet HashSet ArrayList ：每次增长到 1.5 倍Vector ：每次增长到原来的 2 倍 List、Set、Map 的区别 集合 元素数量 安全性 特点 ArrayList 单个 不同步 访问效率高；增删效率低 LinkedList 单个 不同步 访问效率低；增删效率高 Vector 单个 同步 访问效率高；增删效率低 HashSet 单个 不同步 不能像 List 那样直接通过 get 索引的方式获取，只能遍历获取 TreeSet 单个 不同步 不能像 List 那样直接通过 get 索引的方式获取，只能遍历获取 对于数字类型和字符类型的对象，还支持自然升序的排序方式 Hashtable 成对 同步 getKey 值的方式访问元素，不允许 null 键和 null 值 HashMap 成对 不同步 getKey 值的方式访问元素，允许一个 null 键和多个 null 值 Map 的实现类 HashMap 和 Hashtable （映射关系 KV Key Value）Hashtable 不允许有 null 键或 null 值 HashMap 允许有 1 个 null 键和多个 null 值Hashtable 基于老版本的抽象类 Dictionary ， HashMap 是较新的实现了 Map 接口的映射管理工具Hashtable 支持线程安全的，同步的； HashMap 不支持线程安全，不同的 HashMap 的效率更高，Hashtable 的效率较低 Collection 和 Collections 的区别 Collection 是接口，实现它的最主要的接口是 List 和 Set Collections 是帮助类，它提供了大量的静态方法，用于对集合的操作、访问、和线程安全化 12345678910111213141516171819202122232425262728293031323334353637package com.hellojava.lesson13;import java.util.ArrayList;import java.util.Collections;import java.util.HashMap;import java.util.HashSet;import java.util.Hashtable;import java.util.List;import java.util.Map;import java.util.Set;import java.util.Vector;public class Demo1 &#123; public static void main(String[] args) &#123; Map map = new HashMap(); // map 当中的键值对 // key 值不能重复 // value 值可以重复 map.put("钥匙1", "牢房1"); map.put("钥匙2", "牢房1"); map.put("钥匙3", "牢房3"); System.out.println(map.size()); System.out.println(map.get("钥匙2")); List list1 = new ArrayList(); list1.add(10); list1.add(9); list1.add(100); list1.add(8); Collections.sort(list1); list1.forEach(s -&gt; System.out.println(s)); Collections.synchronizedMap(map); &#125;&#125; ListIterator 和 Iterator 的区别 ListIterator Iterator 可以向前、向后遍历 只能向后遍历 除了 List 之外的集合都无法遍历 可以遍历所有集合 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.hellojava.it;import java.util.*;public class Demo1 &#123; public static void main(String[] args) &#123; // List // Map List list = new ArrayList(); for (int i = 1; i &lt; 6; i++) &#123; list.add(i); &#125; // 3 种遍历方法 for (int i = 0; i &lt; list.size(); i++) &#123; System.out.println(list.get(i)); &#125; for (Object obj : list) &#123; System.out.println(obj); &#125; list.forEach(s -&gt; System.out.println(s)); list.forEach(System.out::println); // 迭代器 Iterator it = list.iterator(); // readLine(); // 判断迭代器游标下面是否有元素 while (it.hasNext()) &#123; // 得到迭代器游标指示的下一个元素 System.out.println(it.next()); &#125; System.out.println("使用 ListIterator 迭代遍历 List 集合"); ListIterator li = list.listIterator(); while (li.hasNext()) &#123; System.out.println(li.next()); &#125; while (li.hasPrevious()) &#123; System.out.println(li.previous()); &#125; &#125;&#125; 遍历 Map 要遍历 KeySet() 1234567891011121314151617181920212223242526272829package com.hellojava.it;import java.util.HashMap;import java.util.Iterator;import java.util.Map;public class Demo2 &#123; public static void main(String[] args) &#123; Map map = new HashMap(); map.put(1, "111"); map.put(2, "222"); map.put(3, "333"); // foreach 遍历map for (Object obj : map.keySet()) &#123; System.out.print(obj + "---"); System.out.println(map.get(obj)); &#125; // Iterator 遍历map Iterator it = map.keySet().iterator(); while (it.hasNext()) &#123; Object o = it.next(); System.out.println(o + "---" + map.get(o)); &#125; &#125;&#125; 用普通 for 循环删除集合中的元素是安全的。 用 forEach 和 Iterator 删除集合中倒数第二个元素是安全的，删除其他元素会报共发修改异常（ ConcurrentModificationException ），解决方法是：删除后立即 break 。 删除多个元素的安全做法是，先将欲删除的所有元素挑出来加到新定义的集合中，然后，旧集合.removeAll(新集合);一次性删除。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package com.hellojava.it;import java.util.ArrayList;import java.util.Iterator;import java.util.List;public class Demo3 &#123; public static void main(String[] args) &#123; List list = new ArrayList(); for (int i = 1; i &lt; 6; i++) &#123; list.add(i); &#125; list.forEach(System.out::print); System.out.println(); for (int i = 0; i &lt; list.size(); i++) &#123; if (i == 1) &#123; list.remove(list.get(i)); &#125; &#125; // 删除倒数第二个元素可以正常进行 // 删除其他位置的元素会报错 // 由于迭代器自动生成的 modCount 赋值给了expectedModCount， // 删除一个元素会导致这两个值不相等，然后报错 // 在删除了倒数第二个元素后，游标的位置和集合的大小相等了，if 条件不满足，就不会往下走了 for (Object obj : list) &#123; if (obj.equals(1)) &#123; list.remove(obj); break; &#125; &#125; Iterator it = list.iterator(); while (it.hasNext()) &#123; Object o = it.next(); if (new Integer(1).equals(o)) &#123; list.remove(o); break; &#125; &#125; // 需求：删除所有偶数值的元素 List mylist = new ArrayList(); for (int i = 0; i &lt; list.size(); i++) &#123; Object o = list.get(i); // 先判断并收集所有需要删除的元素 if (((Integer) o % 2) == 0) &#123; mylist.add(o); &#125; &#125; // 一次性删除 list.removeAll(mylist); System.out.println(); list.forEach(System.out::print); &#125;&#125; 进程、线程进程是系统中独立运行的最小程序单元，一个进程中包含 1~n 个线程线程是一个进程中独立运行的最小程序单元 实现线程的两种方法 继承 Thread 类 实现 Runnable 接口 实现 Runnable 接口比继承 Thread 类好： 排除 java 单继承的限制 方便共享资源 线程的五种状态 状 态 解 释 1. 新生/初始状态 new 出来的线程就进入新生状态 2. 就绪状态 .start 3. 运行状态 得到 CPU 时间片的线程为运行状态 4. 阻塞状态 .sleep .interrupt 5. 死亡状态 .stop 优先级（1~10）建议系统优先运行 123456public class MyThread extends Thread &#123; @Override public void run() &#123; &#125;&#125; 123456public class MyRunnable implements Runnable &#123; @Override public void run() &#123; &#125;&#125; 12345678910111213141516public class Demo &#123; public static void main(String[] args) &#123; // 实现线程的两种方法 MyThread my1 = new MyThread(); Thread my2 = new Thread(new MyRunnable); my1.star(); // 进入阻塞状态 my2.suspend(); // 恢复挂起的线程 my2.resume(); my1.setPriority(Thread.MAX_PRIORITY); my2.setPriority(Thread.MIN_PRIORITY); // 子线程加入主线程，主线程必须等待子线程结束才能结束 my1.join(); &#125;&#125; 数据库连接JDBCJava DataBase ConnectivityJava 数据库连接 ODBC COpen DataBase ConnectivityWOSA Windows Open Server Architecture JDBC vs ODBC JDBC 有面向对象的思想，类、接口；ODBC 面向过程的思想。当满足相同需求的时候，JDBC 往往节省了更多的代码。入门更容易，开发效率更高。 移植性。搭建 ODBC 环境需要驱动、配置，只能应用于一个数据库。JDBC 只需要简单的配置和驱动就可以适应多个数据库，移植性更佳。 驱动。JDBC 的每一个数据库的驱动由数据库厂商自己编写。ODBC 由微软写驱动。 连接方式。JDBC 使用 Java 访问互联网的连接方式（URL Uniform Resources Location 统一资源标识符）。ODBC 必须依赖本地连接。 JDK5（2004.9.30）JDBC-ODBC 桥连接：数据源。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586package com.hellojava;import java.sql.Connection;import java.sql.DriverManager;import java.sql.ResultSet;import java.sql.SQLException;import java.sql.Statement;public class Demo &#123; public static void main(String[] args) &#123; /* * 1、加载驱动 2、创建连接 3、创建命令 4、执行命令 5、关闭连接 */ // 1、加载驱动 // 反射 // com.mysql.jdbc.Driver.class Connection conn = null; try &#123; Class.forName("com.mysql.jdbc.Driver"); // 创建到数据库的连接 // Wrapper接口 -&gt; 子接口 Connection 用于建立到数据库的连接，执行sql，返回结果 // DriverManager // 数据源：getConnection方法会建立一个到指定URL的连接 // protocol http https ftp .. // user 访问数据库的用户名 // password 对应的密码 String url = "jdbc:mysql://127.0.0.1:3306/test1013"; String user = "root"; String password = "a111"; conn = DriverManager.getConnection(url, user, password); // 创建命令对象 // Statement stm = conn.createStatement(); // String sql = "delete from BOOK where bookId=70105"; // int a = stm.executeUpdate(sql); Statement stm = conn.createStatement(); String sql = "select * from book where bookId &gt; 70000"; // ResultSet 结果集 只能正向遍历，而且必须全部遍历 // 连线结果集，不能在读取之前关闭 ResultSet rs = stm.executeQuery(sql); while (rs.next()) &#123; System.out.print("bookId=" + rs.getString("bookId")); System.out.print("\tbookName=" + rs.getString("bookName")); System.out.print("\tbookPrice=" + rs.getDouble("bookPrice")); System.out.print("\tbookAuthor=" + rs.getString("bookAuthor")); System.out.println("\tbookInfo=" + rs.getString("bookInfo")); &#125; // Prepare is half the battle; // String sql = "INSERT INTO BOOK VALUES(DEFAULT,?,?,?,?)"; // PreparedStatement ps = conn.prepareStatement(sql); // ps.setString(1, "红楼梦"); // ps.setDouble(2, 99.98); // ps.setString(3, "曹雪芹"); // ps.setString(4, "测试"); // int a = ps.executeUpdate(); // 处理结果 // System.out.println("SQL执行完毕，" + (a &gt; 0 ? "成功" : "失败")); &#125; catch (ClassNotFoundException e) &#123; System.out.println("驱动程序加载失败"); e.printStackTrace(); &#125; catch (SQLException e) &#123; System.out.println("SQL异常！"); e.printStackTrace(); &#125; finally &#123; // 关闭连接 try &#123; conn.close(); &#125; catch (SQLException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package com.hellojava.test;import java.sql.Connection;import java.sql.DriverManager;import java.sql.ResultSet;import java.sql.SQLException;import java.sql.Statement;public class Demo &#123; public static void main(String[] args) &#123; try &#123; // 1、加载驱动 // 设计模式 // "com.mysql.jdbc.Driver" // "com.microsoft.sqlserver.sqlserver.Driver" Class.forName("com.mysql.jdbc.Driver"); // 2、建立连接 // localhost = 127.0.0.1 String url = "jdbc:mysql://localhost:3306/test1013"; String user = "root"; String password = "a111"; Connection conn = DriverManager.getConnection(url, user, password); // 3、创建命令对象 // Wrapper Statement stm = conn.createStatement(); String sql = "select * from book order by bookId desc limit 100"; // 4、执行命令，处理结果 ResultSet rs = stm.executeQuery(sql); while(rs.next())&#123; System.out.print("bookId:"+rs.getInt("bookId")); System.out.print("\tbookName:"+rs.getString("bookName")); System.out.println("\tbookAuthor:"+rs.getObject("bookAuthor")); &#125; // 5、关闭连接 conn.close(); // 1、高内聚 // 2、低耦合 &#125; catch (ClassNotFoundException e) &#123; System.out.println("找不到驱动"); e.printStackTrace(); &#125; catch(SQLException e)&#123; System.out.println("SQL异常"); &#125; &#125;&#125; Statement PreparedStatement CallableStatement 区别父接口 Wrapper -&gt; Statement -&gt; PreparedStatement -&gt; CallableStatementStatement 用来创建并执行SQL，然后返回一个值PreparedStatement 预编译的 SQL 命令对象，支持输入参数CallableStatement 可以支持输入输出参数的SQL命令对象（ Procedure ） PreparedStatement （以下简称 PS）优点Statement -&gt; JVM -&gt; DBMS 编译 -&gt; 解释 PS 提升了效率。（数据库预编译，命令池） 代码易读性、可维护性提升 PS 可以有效地预防 SQL 注入 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113package com.hellojava.test;import java.sql.CallableStatement;import java.sql.Connection;import java.sql.DriverManager;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.SQLException;import java.sql.Types;public class Demo2 &#123; // 解耦合 // 匿名静态代码块,只执行一次 static &#123; try &#123; Class.forName("com.mysql.jdbc.Driver"); System.out.println("驱动加载完毕"); &#125; catch (ClassNotFoundException e) &#123; System.out.println("加载驱动失败"); e.printStackTrace(); &#125; &#125; // 建立连接 public Connection openConnection(String url, String user, String password) &#123; Connection conn = null; try &#123; conn = DriverManager.getConnection(url, user, password); &#125; catch (SQLException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; return conn; &#125; // 关闭连接 public void closeConnection(Connection conn) &#123; try &#123; // 空值判断 if (conn != null &amp;&amp; !conn.isClosed()) &#123; conn.close(); &#125; &#125; catch (SQLException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; // 增删改 // Object[] obs public int update(Connection conn, String sql, Object... obs) &#123; int a = 0; try &#123; PreparedStatement ps = conn.prepareStatement(sql); // 组装SQL if (obs != null) &#123; for (int i = 0; i &lt; obs.length; i++) &#123; ps.setObject((i + 1), obs[i]); &#125; &#125; a = ps.executeUpdate(); &#125; catch (SQLException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; return a; &#125; public Object call(Connection conn, String sql, Object... obs) &#123; int bs = 0; try &#123; CallableStatement cs = conn.prepareCall(sql); // 组装SQL if (obs != null) &#123; for (int i = 0; i &lt; obs.length; i++) &#123; cs.setObject((i + 1), obs[i]); if (i == obs.length - 1) &#123; // 注册的输出值 cs.registerOutParameter((i + 1), Types.INTEGER); &#125; &#125; &#125; System.out.println(cs.executeUpdate()); // 得到存储过程中的输出值 bs = cs.getInt(3); &#125; catch (SQLException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; return bs; &#125; // 查询 public ResultSet query(String sql, Connection conn, Object... obs) &#123; ResultSet rs = null; try &#123; PreparedStatement ps = conn.prepareStatement(sql); if (obs != null) &#123; for (int i = 0; i &lt; obs.length; i++) &#123; ps.setObject((i + 1), obs[i]); &#125; &#125; rs = ps.executeQuery(); &#125; catch (SQLException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; return rs; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536package com.hellojava.test;import java.sql.Connection;import java.sql.ResultSet;import java.sql.SQLException;public class TestDemo2 &#123; public static void main(String[] args) &#123; Demo2 d2 = new Demo2(); Connection conn = d2.openConnection("jdbc:mysql://localhost:3306/test1013", "root", "a111");// String sql = "insert into book values(default,?,?,?,?)";// Object[] obs = &#123; "红楼梦", 200, "曹雪芹", "测试数据" &#125;;//// int a = d2.update(conn, sql, obs);// System.out.println("SQL 执行完毕，" + (a &gt; 0 ? "成功" : "失败"));//// String sql = "select * from book where bookId &gt; 70000";// ResultSet rs = d2.query(sql, conn, null);// try &#123;// while (rs.next()) &#123;// System.out.print("bookId:" + rs.getObject("bookId"));// System.out.println("\tbookName:" + rs.getObject("bookName"));// &#125;// &#125; catch (SQLException e) &#123;// // TODO Auto-generated catch block// e.printStackTrace();// &#125; String sql = "Call myproc3(?,?,?)"; Object[] obs = &#123; 1, 100, "@result" &#125;; System.out.println(d2.call(conn, sql, obs)); d2.closeConnection(conn); &#125;&#125; 前台项目（结构） css 文件夹 js 文件夹 img 文件夹 res 文件夹 后台项目（包结构）从底层（数据库）向上层（用户视图） database （JDBC 基础驱动和代码） dao 层 数据访问对象 data access object 实体类（JavaBean） book （ bookId, bookName, bookPrice…） Service 业务层/服务层 View 视图层（前台） ATM 终端控制台 View 视图层（前台） 登陆； 存取款 Service 业务层/服务层 判断登陆，注册； 查询余额、取款、存款、转账 实体类（JavaBean） 用户类（银行账户类） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788package com.hellojdbc.datatbase;import java.sql.Connection;import java.sql.DriverManager;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.SQLException;public class DBManager &#123; static &#123; try &#123; Class.forName("com.mysql.jdbc.Driver"); System.out.println("驱动加载完毕"); &#125; catch (ClassNotFoundException e) &#123; System.out.println("加载驱动失败"); e.printStackTrace(); &#125; &#125; private String url = "jdbc:mysql://localhost:3306/test1013"; private String user = "root"; private String password = "a111"; // 建立连接 public Connection openConnection() &#123; Connection conn = null; try &#123; conn = DriverManager.getConnection(url, user, password); &#125; catch (SQLException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; return conn; &#125; // 关闭连接 public void closeConnection(Connection conn) &#123; try &#123; // 空值判断 if (conn != null &amp;&amp; !conn.isClosed()) &#123; conn.close(); &#125; &#125; catch (SQLException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; public int update(Connection conn, String sql, Object... obs) &#123; int a = 0; try &#123; PreparedStatement ps = conn.prepareStatement(sql); // 组装SQL if (obs != null) &#123; for (int i = 0; i &lt; obs.length; i++) &#123; ps.setObject((i + 1), obs[i]); &#125; &#125; a = ps.executeUpdate(); &#125; catch (SQLException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; return a; &#125; // 查询 public ResultSet query(Connection conn, String sql, Object... obs) &#123; ResultSet rs = null; try &#123; PreparedStatement ps = conn.prepareStatement(sql); if (obs != null) &#123; for (int i = 0; i &lt; obs.length; i++) &#123; ps.setObject((i + 1), obs[i]); &#125; &#125; rs = ps.executeQuery(); &#125; catch (SQLException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; return rs; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334package com.hellojdbc.datatbase.dao;import java.sql.Connection;import java.sql.ResultSet;import java.sql.SQLException;import com.hellojdbc.datatbase.DBManager;import com.hellojdbc.entity.User;public class UserDao extends DBManager &#123; public int login(User user) &#123; Connection conn = this.openConnection(); // select * from myuser where uName='王大锤' and uPwd='1234'; // String sql = "select * from myuser where uName='" + user.getuName() + // "' and uPwd='" + user.getuPwd() + "'"; // System.out.println(sql); String sql = "select * from myuser where uName=? and uPwd=?"; String[] obs = &#123; user.getuName(), user.getuPwd() &#125;; int a = 0; ResultSet rs = this.query(conn, sql, obs); try &#123; if (rs.next()) &#123; a = 1; &#125; &#125; catch (SQLException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; this.closeConnection(conn); return a; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.hellojdbc.entity;// 用户实体类public class User &#123; // 对应myuser表中的uId列 private int uId; // 对应myuser表中的uName列 private String uName; // 对应myuser表中的uPwd列 private String uPwd; // 对应myuser表中的uBalance列 private double uBalance; public int getuId() &#123; return uId; &#125; public void setuId(int uId) &#123; this.uId = uId; &#125; public String getuName() &#123; return uName; &#125; public void setuName(String uName) &#123; this.uName = uName; &#125; public String getuPwd() &#123; return uPwd; &#125; public void setuPwd(String uPwd) &#123; this.uPwd = uPwd; &#125; public double getuBalance() &#123; return uBalance; &#125; public void setuBalance(double uBalance) &#123; this.uBalance = uBalance; &#125;&#125; 123456789101112131415161718package com.hellojdbc.service;import com.hellojdbc.datatbase.dao.UserDao;import com.hellojdbc.entity.User;public class LoginService &#123; public boolean login(User user) &#123; UserDao dao = new UserDao(); int a = dao.login(user); boolean isValid = false; if (a &gt; 0) &#123; isValid = true; &#125; return isValid; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536package com.hellojdbc.view;import java.util.Scanner;import com.hellojdbc.entity.User;// 登陆视图public class LoginView &#123; public void paintLogin() &#123; System.out.println("*********************************"); System.out.println("*\t\t\t\t*"); System.out.println("*\t欢迎光临ATM终端机\t\t*"); System.out.println("*\t\t\t\t*"); System.out.println("*********************************"); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; public User login() &#123; System.out.println("请输入用户名..."); Scanner in = new Scanner(System.in); String uName = in.nextLine(); System.out.println("请输入密码..."); String uPwd = in.nextLine(); User u = new User(); u.setuName(uName); u.setuPwd(uPwd); return u; &#125;&#125; 1234567891011121314151617181920package com.hellojdbc.view;import com.hellojdbc.entity.User;import com.hellojdbc.service.LoginService;public class OverAll &#123; public static void main(String[] args) &#123; LoginView lv = new LoginView(); lv.paintLogin(); User user = lv.login(); LoginService ls = new LoginService(); if (ls.login(user)) &#123; System.out.println("登陆成功，欢迎" + user.getuName() + "回来！"); &#125; else &#123; System.out.println("用户名或密码错误！"); &#125; &#125;&#125;]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
  </entry>
</search>
